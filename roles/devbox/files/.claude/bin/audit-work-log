#!/usr/bin/env bash
# audit-work-log — Detect lazy agent patterns in SE output artifacts.
#
# Scans agent output for excuse phrases that indicate fabricated results,
# and verifies that required commands were actually executed per language.
#
# Usage: audit-work-log [--se-output <path>] [--lang <go|python|node>] [--json]
#
# Exit codes:
#   0  Clean (no patterns detected, all required commands present)
#   1  Advisory patterns detected (possible false positives — warn only)
#   2  Missing mandatory commands (advisory — not all tools always needed)
#   3  Both advisory patterns and missing commands
#   4  BLOCKING patterns detected (high-confidence fabrication — should block pipeline)

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BOLD='\033[1m'
NC='\033[0m'

if [[ ! -t 1 ]]; then
  RED='' GREEN='' YELLOW='' BOLD='' NC=''
fi

# --- BLOCKING patterns: high-confidence fabrication, no legitimate use in SE output ---
BLOCKING_PATTERNS=(
  "manually verified"
  "verified by inspection"
  "verified by reading"
  "unable to run"
  "could not execute"
  "could not run"
  "sandbox blocks"
  "sandbox restrict"
  "visual inspection"
  "code review only"
  "static analysis only"
  "limited to import resolution"
  "verified via import"
)

# --- ADVISORY patterns: could be false positives in context ---
ADVISORY_PATTERNS=(
  "manual review"
  "appears correct"
  "looks correct"
  "should work"
  "tests appear"
  "would succeed"
  "would work outside"
  "reviewed the code"
  "checked the logic"
)

# --- Required commands by language (Bash 3.2 compatible — no associative arrays) ---
required_commands_for() {
  case "$1" in
    go)     echo "go build|go test|golangci-lint|goimports" ;;
    python) echo "pytest|ruff check|ruff format|mypy|pyright" ;;
    node)   echo "tsc|vitest|jest|eslint|prettier" ;;
    *)      echo "" ;;
  esac
}

# --- Parse args ---
se_output=""
lang=""
json_output=false

usage() {
  cat <<'EOF'
Usage: audit-work-log [--se-output <path>] [--lang <go|python|node>] [--json]

Options:
  --se-output <path>   SE agent output file to scan
  --lang <go|python|node>  Language to check required commands for
  --json               Output machine-readable JSON
  -h, --help           Show this help

Exit codes:
  0  Clean
  1  Advisory patterns detected (warn only)
  2  Missing mandatory commands (warn only)
  3  Both advisory patterns and missing commands
  4  BLOCKING patterns detected (high-confidence fabrication)
EOF
  exit 0
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --se-output) se_output="$2"; shift 2 ;;
    --lang) lang="$2"; shift 2 ;;
    --json) json_output=true; shift ;;
    -h|--help) usage ;;
    *) echo "Unknown option: $1" >&2; exit 10 ;;
  esac
done

# --- Validation ---
if [[ -z "$se_output" ]]; then
  echo -e "${RED}ERROR${NC}: --se-output is required" >&2
  exit 10
fi

if [[ ! -f "$se_output" ]]; then
  echo -e "${RED}ERROR${NC}: SE output file not found: $se_output" >&2
  exit 10
fi

# --- Scan for patterns ---
found_blocking=()
found_advisory=()
content=$(cat "$se_output")

for pattern in "${BLOCKING_PATTERNS[@]}"; do
  if echo "$content" | grep -qi "$pattern"; then
    found_blocking+=("$pattern")
  fi
done

for pattern in "${ADVISORY_PATTERNS[@]}"; do
  if echo "$content" | grep -qi "$pattern"; then
    found_advisory+=("$pattern")
  fi
done

# --- Check required commands ---
missing_commands=()
if [[ -n "$lang" ]]; then
  _req_cmds=$(required_commands_for "$lang")
  if [[ -n "$_req_cmds" ]]; then
    IFS='|' read -ra cmds <<< "$_req_cmds"
    for cmd in "${cmds[@]}"; do
      if ! echo "$content" | grep -q "$cmd"; then
        missing_commands+=("$cmd")
      fi
    done
  fi
fi

# --- Compute exit code (blocking > advisory > missing) ---
has_blocking=false
has_advisory=false
has_missing=false
[[ ${#found_blocking[@]} -gt 0 ]] && has_blocking=true
[[ ${#found_advisory[@]} -gt 0 ]] && has_advisory=true
[[ ${#missing_commands[@]} -gt 0 ]] && has_missing=true

exit_code=0
if $has_blocking; then
  exit_code=4
elif $has_advisory && $has_missing; then
  exit_code=3
elif $has_advisory; then
  exit_code=1
elif $has_missing; then
  exit_code=2
fi

# --- Output ---
if $json_output; then
  # Build JSON arrays
  blocking_json="["
  for i in "${!found_blocking[@]}"; do
    [[ $i -gt 0 ]] && blocking_json+=","
    blocking_json+="\"${found_blocking[$i]}\""
  done
  blocking_json+="]"

  advisory_json="["
  for i in "${!found_advisory[@]}"; do
    [[ $i -gt 0 ]] && advisory_json+=","
    advisory_json+="\"${found_advisory[$i]}\""
  done
  advisory_json+="]"

  missing_json="["
  for i in "${!missing_commands[@]}"; do
    [[ $i -gt 0 ]] && missing_json+=","
    missing_json+="\"${missing_commands[$i]}\""
  done
  missing_json+="]"

  cat <<EOF
{
  "status": "$(if [[ $exit_code -eq 0 ]]; then echo "clean"; elif [[ $exit_code -eq 4 ]]; then echo "blocked"; else echo "flagged"; fi)",
  "blocking_patterns_found": $blocking_json,
  "advisory_patterns_found": $advisory_json,
  "missing_commands": $missing_json,
  "exit_code": $exit_code
}
EOF
else
  echo -e "${BOLD}SE Output Audit${NC}"
  echo "─────────────────────────────"

  if $has_blocking; then
    echo -e "\n${RED}BLOCKING — high-confidence fabrication patterns:${NC}"
    for e in "${found_blocking[@]}"; do
      echo -e "  ${RED}X${NC}  \"$e\""
    done
  fi

  if $has_advisory; then
    echo -e "\n${YELLOW}Advisory — possible excuse patterns:${NC}"
    for e in "${found_advisory[@]}"; do
      echo -e "  ${YELLOW}!${NC}  \"$e\""
    done
  fi

  if ! $has_blocking && ! $has_advisory; then
    echo -e "\n${GREEN}No excuse patterns found.${NC}"
  fi

  if [[ -n "$lang" ]]; then
    if $has_missing; then
      echo -e "\n${YELLOW}Missing required commands ($lang):${NC}"
      for m in "${missing_commands[@]}"; do
        echo -e "  ${YELLOW}?${NC}  $m"
      done
      echo -e "\n  Note: not all commands are always needed. This is advisory."
    else
      echo -e "\n${GREEN}All expected commands found for $lang.${NC}"
    fi
  fi

  echo ""
fi

exit $exit_code
