#!/usr/bin/env node

// pre-write-completion-gate — PreToolUse hook that blocks writes to SE output
// artifacts unless the project actually builds and lints cleanly.
//
// Intercepts Write calls targeting filenames matching se_*_output.json
// (e.g., se_go_output.json, se_python_output.json, se_frontend_output.json).
//
// When matched, finds the project root and runs verify-se-completion --json
// to confirm build+lint pass before allowing the write.
//
// Event: PreToolUse (matcher: Write)
// Exit 0 = allow, Exit 2 = block

require("./env-setup");

const { execSync } = require("child_process");
const path = require("path");
const fs = require("fs");

// Pattern matches any SE output artifact: se_{suffix}_output.json
const SE_ARTIFACT_RE = /^se_([a-z]+)_output\.json$/;

// Artifact suffix → verify-se-completion --lang value
const SUFFIX_TO_LANG = { go: "go", python: "python", frontend: "node" };

// Marker files for project root detection (language derived from filename, not markers)
const ROOT_MARKERS = ["go.mod", "pyproject.toml", "uv.lock", "poetry.lock", "package.json", "Cargo.toml"];

function langFromFilename(fileName) {
  const m = fileName.match(SE_ARTIFACT_RE);
  return m ? SUFFIX_TO_LANG[m[1]] || null : null;
}

function findProjectRoot(filePath) {
  let dir = path.dirname(filePath);
  for (let i = 0; i < 20; i++) {
    for (const marker of ROOT_MARKERS) {
      if (fs.existsSync(path.join(dir, marker))) return dir;
    }
    const parent = path.dirname(dir);
    if (parent === dir) break;
    dir = parent;
  }
  return null;
}

async function main() {
  let input = "";
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  let data;
  try {
    data = JSON.parse(input);
  } catch {
    process.exit(0);
  }

  const toolInput = data.tool_input || {};
  const filePath = toolInput.file_path || "";

  if (!filePath) {
    process.exit(0);
  }

  // Check if the target file is an SE artifact
  const fileName = path.basename(filePath);
  if (!SE_ARTIFACT_RE.test(fileName)) {
    process.exit(0);
  }

  // Extract language from artifact filename (se_go_output.json → go)
  const lang = langFromFilename(fileName);
  if (!lang) {
    process.stderr.write(
      `BLOCKED: Unknown language suffix in artifact "${fileName}". Known suffixes: ${Object.keys(SUFFIX_TO_LANG).join(", ")}.\n`
    );
    process.exit(2);
  }

  // Find project root (marker-based walk, language already known from filename)
  const projectRoot = findProjectRoot(filePath);
  if (!projectRoot) {
    process.stderr.write(
      "BLOCKED: Could not detect project root for SE artifact verification. Cannot write completion artifacts without a verifiable project.\n"
    );
    process.exit(2);
  }

  // Check that verify-se-completion exists
  const HOME = process.env.HOME || process.env.USERPROFILE || "/tmp";
  const verifyScript = path.join(HOME, ".claude", "bin", "verify-se-completion");
  if (!fs.existsSync(verifyScript)) {
    process.stderr.write(
      "BLOCKED: verify-se-completion script not found at " + verifyScript + ". Cannot write completion artifacts without verification infrastructure.\n"
    );
    process.exit(2);
  }

  // Run verification
  try {
    const result = execSync(
      `"${verifyScript}" --lang ${lang} --work-dir "${projectRoot}" --json`,
      { timeout: 120000, encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] }
    );

    let parsed;
    try {
      parsed = JSON.parse(result.trim());
    } catch {
      // Could not parse JSON — fail closed: block the write
      process.stderr.write(
        "BLOCKED: Could not parse verification output. Cannot confirm build/lint status.\n"
      );
      process.exit(2);
    }

    if (parsed.result === "PASS") {
      process.exit(0);
    }

    // Build failure details
    const failures = [];
    if (parsed.checks) {
      for (const [check, info] of Object.entries(parsed.checks)) {
        if (info.status === "FAIL") {
          failures.push(`  ${check}: ${info.detail}${info.error ? " — " + info.error.slice(0, 200) : ""}`);
        }
      }
    }

    process.stderr.write(
      `BLOCKED: Build/lint verification failed. Fix these before writing completion artifacts.\n` +
        failures.join("\n") +
        "\n"
    );
    process.exit(2);
  } catch (err) {
    // If the script failed with a non-zero exit, it means checks failed
    if (err.status && err.stdout) {
      let parsed;
      try {
        parsed = JSON.parse(err.stdout.trim());
      } catch {
        // Non-JSON output from a failure
        process.stderr.write(
          `BLOCKED: Build/lint verification failed.\n${(err.stderr || err.stdout || "").slice(0, 500)}\n`
        );
        process.exit(2);
      }

      const failures = [];
      if (parsed && parsed.checks) {
        for (const [check, info] of Object.entries(parsed.checks)) {
          if (info.status === "FAIL") {
            failures.push(`  ${check}: ${info.detail}${info.error ? " — " + info.error.slice(0, 200) : ""}`);
          }
        }
      }

      process.stderr.write(
        `BLOCKED: Build/lint verification failed. Fix these before writing completion artifacts.\n` +
          failures.join("\n") +
          "\n"
      );
      process.exit(2);
    }

    // Timeout or other error — block to prevent unverified artifacts
    process.stderr.write(
      `BLOCKED: Verification error (${err.message}). Fix the verification infrastructure before writing completion artifacts.\n`
    );
    process.exit(2);
  }
}

main();
